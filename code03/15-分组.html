<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script type="text/javascript">
			
			// 利用正则表达式匹配提取的结果是一个数字类型的对象
			// 其中 第 0 项 就是匹配的结果
			// 第 1 项 或 第 n 项是什么呢?
			
			// 在完成一次匹配的时候, 可以捕获匹配到的字符串内部的结构
			// var str = "jim@itcast.cn, tom@126.com, jack@163.com";
			/*
			// [^,]+
			var r = /[^,]+/g;
			var m, arr = [];
			while ( m = r.exec( str ) ) {
				arr.push( m[ 0 ] );
			}
			*/
			
			// 但是有些时候我们希望可以对匹配到的结果进行解析
			// 传统分析邮箱的步骤
			// 1> 获取邮箱的全名( 传统, 正则 )
			// 2> 循环解析
			/*
			for ( i -> n ) {
				var temp = v.split( '@' )
				arr.push( { name: temp[0], location: temp[1] } )
			}
			*/
			// 3> 存储
			
			// 正则表达式在匹配的过程中就可以给你解析完成
			// .	任意除了换行意外的任意字符
			// ()	分组
			// +	代表紧挨的字符或字符组出现 1 次到多次 ( 默认匹配最多 )
			// ?	1> 0次或1次, 2> 放在次数限定元字符后表示尽可能少匹配
			// .+@.+
			var str = "jim@itcast.cn, tom@126.com, jack@163.com";
			var r = /(.+?)@(.+?)/;
			var m = r.exec( str );
			
			// 术语
			// 范围匹配在正则中都是默认的贪婪模式
			// 添加 ? 表示取消贪婪模式
			
			
			// 分组的技巧
			// 允许在正则表达式中使用 多个圆括号对结果分组, 分组后匹配到的结果可以直接获取对应的部分
			// 但是复杂分组难以分析, 有一个技巧
			// 1, 从左往右数 (
			// 2, 从 1 开始给 ( 编号
			// 那么匹配的结果 对应的 下标就是该圆括号分的的内容
			
			// 练习: "(a(b(c)))" 分别给出每一组的序号
			
		</script>
	</head>
	<body>
	</body>
</html>
